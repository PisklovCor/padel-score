# Анализ: рейтинг игроков (ELO) и триггер на INSERT match_results

## 1. Текущее состояние проекта

### 1.1 Таблицы

- **match_results** — результат матча:
  - `match_id`, `winner_team_id`, `loser_team_id`, `winner_points`, `loser_points`, `final_score` (например "2-0", "2-1"), `submitted_at`.
- **player_profiles** — профиль игрока: поле `rating` (INTEGER, nullable). Сейчас при создании через бота передаётся **0** (`CommandCreatePlayerProfile`, `CallbackCreatePlayerProfile`).
- **team_players** — связь команда ↔ игроки: `team_id`, `player_profile_id`. В матче участвуют две команды (по 2+ игрока).

### 1.2 Очки за матч (уже реализовано в `MatchService.calculateScore`)

- **2-0 / 0-2:** победитель **4**, проигравший **0**.
- **2-1 / 1-2:** победитель **3**, проигравший **1**.

Соответствует описанной в PRD расширенной модели (п. 7.1).

### 1.3 Рейтинг сейчас

- Задаётся вручную при создании/обновлении профиля или **0** при создании через Telegram.
- Автоматического пересчёта по результатам матчей нет.
- `StatisticsService.getTopPlayersByRating()` и рейтинг в UI просто читают `player_profiles.rating`.

---

## 2. Цель

- В БД — **триггер на INSERT (и при необходимости UPDATE) таблицы match_results**.
- При появлении/изменении результата — **пересчёт рейтинга игроков** по правилам, похожим на ELO.
- Стартовый рейтинг нового игрока — **500** (вместо текущего 0).
- Очки за матч оставить или скорректировать (ниже предложен вариант).

---

## 3. Рекомендуемая модель рейтинга (ELO-подобная)

- **Базовый рейтинг:** 500 (для новых игроков: `COALESCE(rating, 500)` в формулах и при инициализации в приложении).
- **Единица учёта:** матч команда против команды. Рейтинг считаем **по игрокам**, но результат матча один на команду (победа/поражение).

Варианты расчёта на матч:

- **Вариант A (рейтинг команды = среднее рейтингов игроков).**  
  Рейтинг победившей команды `R_w = (R1_w + R2_w) / 2`, проигравшей `R_l`. Ожидаемый результат для победителя: `E_w = 1 / (1 + 10^((R_l - R_w) / 400))`. Фактический: 1 (победа). Изменение рейтинга: `Δ = K * (1 - E_w)`. Прибавить `Δ` каждому игроку победившей команды, вычесть `Δ` каждому игроку проигравшей (или распределить поровну: по `Δ/2` на команду — тогда у каждой команды по два игрока, оба получают одно и то же изменение). K обычно 32 (можно 24–40).
- **Вариант B (учёт счёта).**  
  То же, но множитель зависит от счёта: например при 2-0 давать полный K, при 2-1 — 0.75*K, чтобы «сухая» победа сильнее влияла на рейтинг.

Формулы (для триггера, псевдокод):

- `R_winner_team = AVG(rating) по игрокам winner_team_id из team_players`, рейтинг по умолчанию 500.
- `R_loser_team = AVG(rating) по игрокам loser_team_id`.
- `E_winner = 1 / (1 + 10^((R_loser_team - R_winner_team) / 400))`.
- `delta = K * (1 - E_winner)` (K = 32 или с учётом счёта).
- Для каждого `player_profile_id` победившей команды: `rating = COALESCE(rating, 500) + delta` (или +delta/2 если делить на число игроков команды).
- Для каждого `player_profile_id` проигравшей команды: `rating = COALESCE(rating, 500) - delta` (или -delta/2).

Важно: при **UPDATE** результата матча нужно либо откатить старые изменения рейтинга и применить новые, либо пересчитать рейтинги «с нуля» по всем матчам в хронологическом порядке. В триггере проще всего при INSERT и UPDATE вызывать одну и ту же функцию пересчёта **всех** рейтингов по всем `match_results` (ORDER BY submitted_at), иначе при изменении результата придётся хранить историю рейтингов или дельты по матчам.

---

## 4. Триггер на таблице match_results

### 4.1 События

- **AFTER INSERT** — после вставки результата пересчитать рейтинг игроков (всех, кто участвовал в матчах, или всех игроков с учётом порядка матчей).
- **AFTER UPDATE** — при изменении результата (winner/loser/счёт) снова пересчитать рейтинг, иначе рейтинги станут несогласованными. Рекомендация: та же функция пересчёта, что и при INSERT.
- **AFTER DELETE** — при удалении результата матча тоже пересчитать (убрать влияние этого матча).

### 4.2 Реализация в БД (идея)

- Новая функция PL/pgSQL, например `recalculate_player_ratings()`, которая:
  1. Для каждого игрока (или только для тех, кто есть в `team_players` в матчах с результатами) устанавливает рейтинг в 500 (стартовое значение).
  2. Обходит все строки `match_results` в порядке `submitted_at` (или `created_at`).
  3. По каждой строке определяет состав команд по `team_players` (winner_team_id, loser_team_id), считает средний рейтинг команд, ожидаемый результат, delta, обновляет `player_profiles.rating` для всех четырёх игроков (двух команд).
- Триггер на `match_results`: при INSERT, UPDATE, DELETE вызывать `recalculate_player_ratings()`.

Ограничение: пересчёт «всего» при каждом изменении результата может быть тяжёлым при большом числе матчей. Альтернатива — триггер только на INSERT и отдельная процедура/задача «пересчитать рейтинги» при редактировании/удалении результата (без автоматического триггера на UPDATE/DELETE).

### 4.3 Уровень рейтинга

- Рейтинг хранится в **player_profiles.rating** (один рейтинг на игрока, глобальный по всем матчам). Турнирных рейтингов в текущей схеме нет.

### 4.4 Начальное значение 500

- В коде создания профиля (Telegram и API) при создании игрока без явного рейтинга подставлять **500** вместо 0.
- В миграции можно добавить `DEFAULT 500` для колонки `rating` и при необходимости обновить существующие NULL/0 на 500 (по политике проекта).

---

## 5. Очки за матч (турнирные баллы командам)

Текущая схема:

- 2-0: победитель **4**, проигравший **0**.
- 2-1: победитель **3**, проигравший **1**.

Предложение (можно оставить как есть или взять один из вариантов):

- **Оставить 4/0 и 3/1** — логично: поощрение за «сухую» победу и утешительное очко за сет.
- **Вариант «всего 3 очка за матч»:** 2-0 → 3/0, 2-1 → 2/1. Меньше разброс, проще объяснить.
- **Вариант «сильнее акцент на 2-0»:** 2-0 → 5/0, 2-1 → 3/1. Сильнее стимул выигрывать «всухую».

Рекомендация: **оставить текущие 4/0 и 3/1** — они уже реализованы в `MatchService` и соответствуют PRD; при необходимости позже можно вынести коэффициенты в настройки турнира/лиги.

---

## 6. План реализации (без правок кода — только план)

1. **Схема и данные**
   - Решить: при создании профиля без рейтинга — писать 500 (в приложении и/или DEFAULT в БД).
   - При необходимости: миграция Liquibase — `rating` DEFAULT 500, обновить существующие NULL/0 → 500 по желанию.

2. **Функция пересчёта рейтинга (PL/pgSQL)**
   - Реализовать `recalculate_player_ratings()`: обнулить рейтинги участников (или всех) к 500, затем в цикле по `match_results` (ORDER BY submitted_at) применять ELO по командам и обновлять `player_profiles.rating`.

3. **Триггер на match_results**
   - AFTER INSERT OR UPDATE OR DELETE вызывать `recalculate_player_ratings()` (или только AFTER INSERT и отдельно вызывать пересчёт при изменении/удалении результата из приложения).

4. **Приложение**
   - В местах создания профиля (Telegram + API) задавать рейтинг по умолчанию **500** вместо 0, если рейтинг не передан явно.
   - Очки за матч оставить как есть (4/0 и 3/1) либо заменить по выбранному варианту из п. 5.

5. **Тесты**
   - Несколько матчей с известными рейтингами, проверка ожидаемых дельт и итоговых рейтингов после INSERT/UPDATE/DELETE.

---

## 7. Краткое резюме

| Вопрос | Решение |
|--------|--------|
| Таблица для рейтинга | `player_profiles.rating` (без изменений схемы). |
| Триггер | AFTER INSERT (и при необходимости UPDATE/DELETE) на `match_results` → вызов функции пересчёта рейтингов. |
| Модель рейтинга | ELO-подобная: рейтинг команды = среднее рейтингов игроков, K≈32, старт 500. |
| Начальный рейтинг | 500 (в приложении и/или DEFAULT в БД). |
| Очки за матч | Оставить 4/0 и 3/1; при желании — вариант 3/0 и 2/1 или 5/0 и 3/1 (см. п. 5). |
| UPDATE результата | Либо пересчёт всех рейтингов в триггере при UPDATE, либо только INSERT + ручной/фоновый пересчёт при изменении результата. |

Дальнейший шаг — реализовать функцию `recalculate_player_ratings()` и триггер в новом changeSet Liquibase и подставить 500 при создании профиля в коде.
